<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于Haas+ESP32-S开发板控制舵机实践</title>
      <link href="/2022/05/03/%E5%88%A9%E7%94%A8Haas+ESP32-S%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/05/03/%E5%88%A9%E7%94%A8Haas+ESP32-S%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
      
      
      <categories>
          
          <category> Haas ESP32S </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习笔记（2）</title>
      <link href="/2022/04/12/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
      <url>/2022/04/12/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div class="note info flat"><p>学习过程跟随<a href="https://space.bilibili.com/277276709">洋桃电子——STM32入门100步</a></p></div><h1 id="关于Cortex系统定时器（SysTick）"><a href="#关于Cortex系统定时器（SysTick）" class="headerlink" title="关于Cortex系统定时器（SysTick）"></a>关于Cortex系统定时器（SysTick）</h1><p>&emsp;&emsp;在“亮灯仪式”之后，接下来就要尝试为LED小灯添加延时以实现亮灭的效果。</p><p>&emsp;&emsp;与传统51相比，事实上STM32的延时大多也采用C语言循环体的方式来进行延时，但是STM32同时也存在计时器进行计时，这一点和定时器中断有点类似。接下来我们就要开始学习一下传说中的“嘀嗒计时器”啦！</p><h2 id="传说中的“嘀嗒计时器”"><a href="#传说中的“嘀嗒计时器”" class="headerlink" title="传说中的“嘀嗒计时器”"></a>传说中的“嘀嗒计时器”</h2><p>&emsp;&emsp;如果你的STM32芯片有操作系统，那么“嘀嗒计时器”可用来切换系统。当然了，我们也可以用来延时，用法与传统51的定时器很类似。我们需要调用相应的函数来使用对应的寄存器，具体的使用在官方文档里有体现。</p><p>&emsp;&emsp;这里我们附上源码来说明：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*****delay.h*****/</span><br><span class="line"><span class="comment">#ifndef __DELAY_H</span></span><br><span class="line"><span class="comment">#define __DELAY_H    </span></span><br><span class="line"><span class="comment">#include &quot;sys.h&quot;</span></span><br><span class="line"> </span><br><span class="line">void delay_s(u16 s);</span><br><span class="line">void delay_ms(u16 ms);</span><br><span class="line">void delay_us(u32 us);</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*****delay.c*****/</span><br><span class="line">/*</span><br><span class="line">//杜洋工作室出品</span><br><span class="line">//洋桃系列开发板应用程序</span><br><span class="line">//关注微信公众号：洋桃电子</span><br><span class="line">//洋桃开发板资料下载 www.DoYoung.net/YT </span><br><span class="line">//即可免费看所有教学视频，下载技术资料，技术疑难提问</span><br><span class="line">//更多内容尽在 杜洋工作室主页 www.doyoung.net</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">《修改日志》</span><br><span class="line">1-201708271933 加入了秒延时函数。</span><br><span class="line">2-201712260223 加入延时前计数器值清0，解决连续用uS延时的BUG问题。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="comment">#define AHB_INPUT  72  //请按RCC中设置的AHB时钟频率填写到这里（单位MHz）</span></span><br><span class="line"></span><br><span class="line">void delay_us(u32 uS)&#123; //uS微秒级延时程序（参考值即是延时数，72MHz时最大值233015）</span><br><span class="line">SysTick-&gt;LOAD=AHB_INPUT*uS;      //重装计数初值（当主频是72MHz，72次为1微秒）</span><br><span class="line">SysTick-&gt;VAL=0x00;        //清空定时器的计数器</span><br><span class="line">SysTick-&gt;CTRL=0x00000005;//时钟源HCLK，打开定时器</span><br><span class="line"><span class="keyword">while</span>(!(SysTick-&gt;CTRL&amp;0x00010000)); //等待计数到0</span><br><span class="line">SysTick-&gt;CTRL=0x00000004;//关闭定时器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delay_ms(u16 ms)&#123; //mS毫秒级延时程序（参考值即是延时数，最大值65535）     </span><br><span class="line"><span class="keyword">while</span>( ms-- != 0)&#123;</span><br><span class="line">delay_us(1000);//调用1000微秒的延时</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void delay_s(u16 s)&#123; //S秒级延时程序（参考值即是延时数，最大值65535）     </span><br><span class="line"><span class="keyword">while</span>( s-- != 0)&#123;</span><br><span class="line">delay_ms(1000);//调用1000毫秒的延时</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*****************************</span><br><span class="line"> * 杜洋工作室 www.DoYoung.net</span><br><span class="line"> * 洋桃电子 www.DoYoung.net/YT </span><br><span class="line">*****************************/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在例程里面我们可以看到，delay函数共分成了delay_us,delay_ms和delay_s三个部分。这里设计的精妙之处在于这三个函数是用层级关系相互嵌套，由例程可知，后面两个部分的延时都是依靠最开始的delay_us，所以我们接下来只要研究delay_us即可。</p><h2 id="SysTick寄存器的使用"><a href="#SysTick寄存器的使用" class="headerlink" title="SysTick寄存器的使用"></a>SysTick寄存器的使用</h2><p><img src="/img/stm/systick.png"></p><p>&emsp;&emsp;根据文档说明，“嘀嗒定时器”还由四个寄存器组成。</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML DOM闲谈</title>
      <link href="/2022/04/12/HTML%20DOM%E9%97%B2%E8%B0%88/"/>
      <url>/2022/04/12/HTML%20DOM%E9%97%B2%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>&emsp;&emsp;这天网站老是访问不了，没想到换了DNS还是不行，上次碰到这么棘手的情况还是上次。几周前同学说起我的网站许久没有更新，细细想来我确实已经很久没有更新博客了。左思右想决定要更新一点什么东西，不然再这样下去就要被人发现我在摸鱼了！</p><p>&emsp;&emsp;前阵子为了研究怎么写油猴脚本，就拿了花园当例子。在看了资料后写了一小段，但由于时间的关系，就没有接着往下写了。<del>其实就是因为懒，所以如果我一事无成，其实一点都不奇怪</del></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// ==UserScript==</span><br><span class="line">// @name         IIrose Tool</span><br><span class="line">// @namespace    IIrose Tool</span><br><span class="line">// @version      0.1</span><br><span class="line">// @description  蔷薇花园拓展功能</span><br><span class="line">// @author       缄默中等待</span><br><span class="line">// @match        https://iirose.com</span><br><span class="line">// @match        http://r.iirose.com</span><br><span class="line">// @icon         https://iirose.com/images/system/ic_square.png</span><br><span class="line">// @grant        none</span><br><span class="line">// ==/UserScript==</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    //alert(<span class="string">&quot;你已装载IIrose Tool&quot;</span>);</span><br><span class="line">    /**********在原有菜单添加功能按钮**********/</span><br><span class="line">    //由于蔷薇花园的网站有“两个网页”，所以这里我采用了以下方法获取“内嵌网页”的“body”,详情请见——https://zhidao.baidu.com/question/1740828295713292667.html</span><br><span class="line">    window.onload = open;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">open</span></span>()&#123;</span><br><span class="line">        var TrueDocument = document.getElementById(<span class="string">&#x27;mainFrame&#x27;</span>).contentDocument;</span><br><span class="line">　　　　document.getElementById(<span class="string">&quot;mainFrame&quot;</span>).src=<span class="string">&#x27;https://iirose.com&#x27;</span>;//这里我索性将ifrme里面的src改成相同的域名，以防止跨域访问无法获取元素</span><br><span class="line">        //找到花园里的菜单栏</span><br><span class="line">        var FucHder = TrueDocument.getElementById(<span class="string">&quot;functionHolder&quot;</span>);</span><br><span class="line">        var FucList = FucHder.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[0];</span><br><span class="line">        FucList.setAttribute(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;Fuclist&#x27;</span>);//为当前的div添加一个<span class="built_in">id</span>以方便后续修改</span><br><span class="line">        var BottomDiv = FucList.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[104];//找到列表里最后一个div</span><br><span class="line">        //在原有的菜单列表当中添加新的选项卡,详情请见——https://zhidao.baidu.com/question/198841713321887885.html</span><br><span class="line">        var divParent = BottomDiv.parentNode;//获取该div的父节点</span><br><span class="line">        var newNode = document.createElement(<span class="string">&quot;div&quot;</span>);//创建新的div节点</span><br><span class="line">        var next = BottomDiv.nextSibling;//获取div的下一个兄弟节点</span><br><span class="line">        divParent.insertBefore(newNode,next);//存在则将新节点插入到div的下一个兄弟节点之前，即div之后</span><br><span class="line">        //在该节点下追加元素与属性</span><br><span class="line">        console.log(FucList);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实写了半天都只是在找关键的view，今天把程序都贴出来，说不定哪天有人用的上呢？对吧！</p>]]></content>
      
      
      <categories>
          
          <category> HYML DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32学习笔记（1）</title>
      <link href="/2022/03/02/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2022/03/02/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div class="note info flat"><p>学习过程跟随<a href="https://space.bilibili.com/277276709">洋桃电子——STM32入门100步</a></p></div><p>&emsp;&emsp;这一篇文章主要是补之前还没说到的一些知识，事实上GPIO的使用是很重要的。</p><h1 id="关于GPIO的使用"><a href="#关于GPIO的使用" class="headerlink" title="关于GPIO的使用"></a>关于GPIO的使用</h1><p>&emsp;&emsp;这里关于GPIO的组成和原理在这里就不多赘述<del>免得我下次没东西写</del>。不然写着写着就和教程没什么区别的，毕竟学东西还是要自己理解才行，等我整明白电路部分再做补充吧！</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（12）</title>
      <link href="/2021/09/29/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89/"/>
      <url>/2021/09/29/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="多位数码管的动态显示（下）"><a href="#多位数码管的动态显示（下）" class="headerlink" title="多位数码管的动态显示（下）"></a>多位数码管的动态显示（下）</h1><h2 id="单片机开发板例程代码详解"><a href="#单片机开发板例程代码详解" class="headerlink" title="单片机开发板例程代码详解"></a>单片机开发板例程代码详解</h2>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（11）</title>
      <link href="/2021/09/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89/"/>
      <url>/2021/09/28/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="多位数码管的动态显示（上）"><a href="#多位数码管的动态显示（上）" class="headerlink" title="多位数码管的动态显示（上）"></a>多位数码管的动态显示（上）</h1><h2 id="单片机课程代码详解"><a href="#单片机课程代码详解" class="headerlink" title="单片机课程代码详解"></a>单片机课程代码详解</h2><div class="note info flat"><p>提示：撰文本文的目的是为了学习交流，仅供参考，不保证其正确性。</p></div><p>&emsp;&emsp;废话少说，上代码！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;STC15.H&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define u8 unsigned char   //将unsigned char重定义为u8，下面一行同理</span></span><br><span class="line"><span class="comment">#define u16 unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define PLed P2   //将单片机的P2口用PLed表示，下面两行同理</span></span><br><span class="line"><span class="comment">#define PSeg P4</span></span><br><span class="line"><span class="comment">#define PSel P6</span></span><br><span class="line"></span><br><span class="line">u8 code SegCode[]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92</span><br><span class="line">  ,0x82,0xf8,0x90,0xbf,0xff,0x8c&#125;;</span><br><span class="line">  //定义一个名为SegCode的数组，用来存放多位数码管的字形码</span><br><span class="line"></span><br><span class="line">u8 DisBuff[4]=&#123;10,10,10,10&#125;;  //该数组用来存放Sec处理后的数据</span><br><span class="line"></span><br><span class="line">void DelayNms(unsigned int i);  //声明子函数，下面两行同理</span><br><span class="line">void Display();</span><br><span class="line">void ToDisBuff();</span><br><span class="line"></span><br><span class="line">u8 Sec;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span> ()</span><br><span class="line">&#123;</span><br><span class="line">u8 s;</span><br><span class="line"><span class="keyword">while</span> (1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(Sec=0;Sec&lt;100;Sec++)</span><br><span class="line">&#123;</span><br><span class="line">ToDisBuff();</span><br><span class="line"><span class="keyword">for</span>(s=0;s&lt;100;s++)  //这里的<span class="keyword">for</span>循环目的是为了延时</span><br><span class="line">Display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DelayNms(unsigned int i)  //延时函数，用于延时</span><br><span class="line">&#123;</span><br><span class="line">unsigned int j;</span><br><span class="line"><span class="keyword">while</span>(i--)</span><br><span class="line"><span class="keyword">for</span>(j=0;j&lt;100;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Display()   //动态显示函数</span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line"><span class="keyword">for</span> (i=1;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">PSel=0x00;  //位选段置零，即没有选择哪一位点亮</span><br><span class="line">PSeg=SegCode[ DisBuff[i] ];</span><br><span class="line">PSel=0x01&lt;&lt;<span class="string">i;</span></span><br><span class="line"><span class="string">DelayNms(1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void ToDisBuff()  //数据处理函数</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">DisBuff[2]=Sec/10;</span></span><br><span class="line"><span class="string">DisBuff[3]=Sec%10;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们按照主函数的运行顺序一一介绍各个子函数的作用。</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Sec=0;Sec&lt;100;Sec++)</span><br><span class="line">&#123;</span><br><span class="line">ToDisBuff();</span><br><span class="line"><span class="keyword">for</span>(s=0;s&lt;100;s++)</span><br><span class="line">Display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的for循环语句，我们可以看到这里Sec被设置初值为0，一共要循环100次（即0-99），这与我们要实现的0-99动态显示这一功能有关。</p><h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void <span class="function"><span class="title">ToDisBuff</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">DisBuff[2]=Sec/10;</span><br><span class="line">DisBuff[3]=Sec%10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的ToDisBuff函数，目的是将for循环当中的Sec进行处理。当for循环开始时，Sec的值为0.经过算式Sec/10（这里是除法运算，计算结果为商，例如25/7的结果为3），得出结果为0，并将0这个结果存入DisBuff[2]。此时在数组DisBuff当中，下表为2的数已经不是10了，而是0。下一句同理，将计算后的值存入DisBuff[3]当中。这里可以自己简单的写一段C代码来证明一下：</p><p><img src="/img/stc/smg/smgsz.png"></p><h3 id="动态显示函数"><a href="#动态显示函数" class="headerlink" title="动态显示函数"></a>动态显示函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Display()   //动态显示函数</span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line"><span class="keyword">for</span> (i=1;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">PSel=0x00;  //位选段置零，即没有选择哪一位点亮</span><br><span class="line">PSeg=SegCode[ DisBuff[i] ];</span><br><span class="line">PSel=0x01&lt;&lt;<span class="string">i;</span></span><br><span class="line"><span class="string">DelayNms(1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的for循环总共循环四次，原因应该是因为本数码管为四位数码管。for循环第一次开始循环时，PSeg开始调用数组SegCode当中的字形码，DisBuff[i]是为了控制字形码数组的角标，当i=1时，得出DisBuff[1]，DisBuff[1]的值为10，即PSeg=SegCode[10]（0xff），接着PSel位选段向左位移1位（因为i=1），之后用延时函数进行延时。</p><div class="note info flat"><p>提示：事实上也可以直接将DelayNms(1);这句改为DelayNms(100);，然后再将主函数里的for(s=0;s&lt;100;s++)注释掉也能达到同样效果。</p></div><p>&emsp;&emsp;因为在这里使用的是共阳数码管，点亮是低电平有效。所以当PSeg=0xff时，数码管不点亮。</p><p>&emsp;&emsp;当循环到第二次时，此时i=2。PSeg=SegCode[DisBuff[2]]=SegCode[0]（0xc0）。接着位选段向左移动2位，在数码管的第三位显示数字0，随着循环的进行依此类推，最终形成了0-99的动态显示。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（10）</title>
      <link href="/2021/09/14/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89/"/>
      <url>/2021/09/14/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8810%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="1602液晶显示（下）"><a href="#1602液晶显示（下）" class="headerlink" title="1602液晶显示（下）"></a>1602液晶显示（下）</h1><h2 id="字符型液晶显示模块指令集"><a href="#字符型液晶显示模块指令集" class="headerlink" title="字符型液晶显示模块指令集"></a>字符型液晶显示模块指令集</h2><p>&emsp;&emsp;上一篇文章中讲到关于初始化液晶屏部分时，出现了以下部分。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LcdWrCmd(0x38);</span><br><span class="line">LcdWrCmd(0x0C);</span><br><span class="line">LcdWrCmd(0x01);</span><br><span class="line">LcdWrCmd(0x06);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;事实上这里的十六进制数并不是凭空产生的，根据资料里的指令集可以得到相应的指令码，根据需要利用指令码向液晶屏发送相关的命令。</p><p><img src="/img/stc/yjp6.png"></p><h3 id="Function-set-功能设置"><a href="#Function-set-功能设置" class="headerlink" title="Function set(功能设置)"></a>Function set(功能设置)</h3><p><img src="/img/stc/yjp7.png"></p><p>&emsp;&emsp;需要说明的是，当DL=1时，使用的是8位数据总线DB7-DB0，即所有的8个IO口。同理，当DL=0时，使用的是4位数据总线，即DB7-DB4，DB3-DB0不用，用此方式传送数据，需要分两次进行。</p><p>&emsp;&emsp;DB1与DB0两个位是 * ，表示无论是0或是1都是可以的。</p><h3 id="Display-on-off-control（显示开-关控制）"><a href="#Display-on-off-control（显示开-关控制）" class="headerlink" title="Display on/off control（显示开/关控制）"></a>Display on/off control（显示开/关控制）</h3><p><img src="/img/stc/yjp8.png"></p><h3 id="Clear-display（清-显示）"><a href="#Clear-display（清-显示）" class="headerlink" title="Clear display（清 显示）"></a>Clear display（清 显示）</h3><p><img src="/img/stc/yjp9.png"></p><p><img src="/img/stc/yjp10.png"></p><p>&emsp;&emsp;上图的00、01、02等地址就是DDROM的地址。</p><p>&emsp;&emsp;地址计数器AC=0时为自动增一模式，这里指的是地址自动增一。如果不是自动增一模式，假设在地址00内表示A,当接下来若表示B时，会把原来的A给覆盖掉。在地址自动增一的情况下，B会被发送到地址01当中。</p><h3 id="Cursor-or-display-shift（游标或显示移位）"><a href="#Cursor-or-display-shift（游标或显示移位）" class="headerlink" title="Cursor or display shift（游标或显示移位）"></a>Cursor or display shift（游标或显示移位）</h3><p><img src="/img/stc/yjp11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（9）</title>
      <link href="/2021/09/14/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89/"/>
      <url>/2021/09/14/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="1602液晶显示（上）"><a href="#1602液晶显示（上）" class="headerlink" title="1602液晶显示（上）"></a>1602液晶显示（上）</h1><p>&emsp;&emsp;事实上利用单片机实现1602显示，首先要经过HD44870芯片（视具体情况）才能控制液晶屏。我们先从液晶屏的引脚说起：</p><p><img src="/img/stc/yjp1.png"></p><h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p>&emsp;&emsp;对于单片机而言，机器只能识别0与1两种，所以为了表达更多的意思，就有了高低电平+时间的表达方式——时序。</p><p><img src="/img/stc/yjp2.png"></p><div class="note info flat"><p>注意：使用速率比较高的芯片（ARM 32）还是需要用延时函数的</p></div><h3 id="写命令-数据程序"><a href="#写命令-数据程序" class="headerlink" title="写命令/数据程序"></a>写命令/数据程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 写命令程序</span><br><span class="line">void LcdWrCmd(uchar cmd) //利用英语单词给变量名“赋义”</span><br><span class="line">&#123;</span><br><span class="line">LcdBusy(); //判断液晶屏状态是否在忙</span><br><span class="line">LcdRS = 0;</span><br><span class="line">LcdRW = 0;</span><br><span class="line">LcdDB = cmd; //数据发送至P2口（参考本篇文章第一张图中的原理图）</span><br><span class="line">LcdEN = 1; //使能引脚先拉高再拉低，将命令写入</span><br><span class="line">LcdEN = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 写数据程序</span><br><span class="line">void LcdWrDat(uchar cmd) //和“写命令程序”原理大同小异</span><br><span class="line">&#123;</span><br><span class="line">LcdBusy();</span><br><span class="line">LcdRS = 1; //引脚电平状态与时序图相对应</span><br><span class="line">LcdRW = 0;</span><br><span class="line">LcdDB = cmd;</span><br><span class="line">LcdEN = 1;</span><br><span class="line">LcdEN = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LcdBusy-函数"><a href="#LcdBusy-函数" class="headerlink" title="LcdBusy 函数"></a>LcdBusy 函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//判断LCD屏是否处于忙状态</span><br><span class="line">void <span class="function"><span class="title">LcdBusy</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">LcdDB = 0xFF; //P2口全部置高电平，一般情况下没有这一句也可以，但是如果程序多的情况下LcdDB有可能在之前就被置为零，所以要全部设置为高电平</span><br><span class="line">LcdRS = 0; //读命令</span><br><span class="line">LcdRW = 1;</span><br><span class="line">LcdEN = 1;</span><br><span class="line"><span class="keyword">while</span>(LcdDB&amp;0x80); //在程序当中,P2口的最高位，如果为1则表示忙，如果为零表示闲。如果LcdDB为1时，与了0x80之后，<span class="keyword">while</span>内为1，函数就会陷入死循环，直到<span class="keyword">while</span>内不为零则跳出循环</span><br><span class="line">LcdEN = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCD1602基本操作"><a href="#LCD1602基本操作" class="headerlink" title="LCD1602基本操作"></a>LCD1602基本操作</h2><p>&emsp;&emsp;具体操作流程分为三步：</p><p>&emsp;&emsp;1、初始化液晶屏<br>&emsp;&emsp;2、指定显示的位置<br>&emsp;&emsp;3、在指定位置显示</p><h3 id="初始化液晶屏"><a href="#初始化液晶屏" class="headerlink" title="初始化液晶屏"></a>初始化液晶屏</h3><p><img src="/img/stc/yjp3.png"></p><h3 id="指定显示位置"><a href="#指定显示位置" class="headerlink" title="指定显示位置"></a>指定显示位置</h3><p><img src="/img/stc/yjp4.png"></p><h3 id="在指定位置显示"><a href="#在指定位置显示" class="headerlink" title="在指定位置显示"></a>在指定位置显示</h3><p><img src="/img/stc/yjp5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（8）</title>
      <link href="/2021/09/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89/"/>
      <url>/2021/09/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>&emsp;&emsp;待填</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（7）</title>
      <link href="/2021/09/08/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/"/>
      <url>/2021/09/08/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="定时器和中断概念的基本认识（上）"><a href="#定时器和中断概念的基本认识（上）" class="headerlink" title="定时器和中断概念的基本认识（上）"></a>定时器和中断概念的基本认识（上）</h1><div class="note info flat"><p>学习过程跟随up主<a href="https://www.bilibili.com/video/BV1vJ411X7iZ?p=9&spm_id_from=pageDriver">@海创电子</a></p></div><p>&emsp;&emsp;经过一段时间的学习，终于走到了定时器中断的部分了！</p><p>&emsp;&emsp;接下来我们主要从两个实验入手：</p><p>&emsp;&emsp;实验一：LED小灯的闪烁<br>&emsp;&emsp;实验二：按键中断法点亮LED</p><p>&emsp;&emsp;在实验开始之前，我们先来了解一些概念。</p><h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>&emsp;&emsp;时钟周期又叫做振荡周期(晶振周期)、节拍周期，定义为时钟晶振频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。例如晶振为12M，则时钟周期为1/12us。又可以被定义为节拍。</p><h2 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h2><p>&emsp;&emsp;在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。一般情况下，一个机器周期由若干个S周期（状态周期）组成。比如，取值周期，取数周期。在80C51内部，机器周期一般包括于6个状态周期，12个时钟周期。例如24M的晶振，机器周期为12/24M秒。</p><div class="note info flat"><p>相关介绍<a href="http://www.51hei.com/bbs/dpj-154301-1.html">单片机时钟周期，机器周期，指令周期之间的关系</a></p></div><div class="note info flat"><p>百度百科：<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F/1545064?fr=aladdin">时钟周期</a>、<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F/276831?fr=aladdin">机器周期</a></p></div><h2 id="情景引入"><a href="#情景引入" class="headerlink" title="情景引入"></a>情景引入</h2><h3 id="例：利用定时器定时20ms"><a href="#例：利用定时器定时20ms" class="headerlink" title="例：利用定时器定时20ms"></a>例：利用定时器定时20ms</h3><p>&emsp;&emsp;我们可以将定时器看作是一个容器，若定时的时间为20ms，则由公式计算可知：</p><p>&emsp;&emsp;次数X(12/12000000)=0.02s，得出次数需要20000次。</p><p>&emsp;&emsp;因为是从0开始计算，所以容器大小为65536，计算得出65536-20000=45536。因此我们需要在“容器”里头预先加载45536大小的“水”。</p><div class="note info flat"><p>注意：这种计算方式需要单片机的晶振频率是12M。</p></div><p><img src="/img/stc/jcq1.png"></p><p>&emsp;&emsp;一般我们常用的模式是“定时模式1”——确定“桶”的大小，接下来将45536如上图所示转化为十六进制进行“装载”。</p><div class="note info flat"><p>注意：上图当中的45536%256结果应为224。</p></div><p>&emsp;&emsp;上图当中出现的两个寄存器——TH0和TL0含义如下：</p><p>&emsp;&emsp;T：time<br>&emsp;&emsp;H：high（高8位）<br>&emsp;&emsp;0：定时器0<br>&emsp;&emsp;L：low（低8位）</p><h2 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h2><p><img src="/img/stc/jcq2.png"></p><p>&emsp;&emsp;这里的TCON（定时器控制寄存器）是可位寻址的，我们既可以把值赋值给整个寄存器（TCON=0xAA），也可以针对该寄存器的单个位进行赋值（TF1=1）。</p><p><img src="/img/stc/jcq3.png"></p><p>&emsp;&emsp;上图当中出现的两个寄存器——TF1和TR1含义如下：</p><p>&emsp;&emsp;T：time<br>&emsp;&emsp;F：flag（标志）——发生“溢出”时，标志位则置“1”<br>&emsp;&emsp;1：定时器1<br>&emsp;&emsp;R：run（运行）——开始往“桶”里“倒水”</p><h2 id="采用查询法配置定时器的四个步骤"><a href="#采用查询法配置定时器的四个步骤" class="headerlink" title="采用查询法配置定时器的四个步骤"></a>采用查询法配置定时器的四个步骤</h2><p><img src="/img/stc/jcq4.png"></p><h3 id="设置TMOD寄存器"><a href="#设置TMOD寄存器" class="headerlink" title="设置TMOD寄存器"></a>设置TMOD寄存器</h3><div class="note info flat"><p>视频里的教程在使用寄存器时，只使用了定时器0。因此在设置TMOD寄存器的时候设置的初始值是0x01。</p></div><p><img src="/img/stc/jcq5.png"></p><p>&emsp;&emsp;在设置寄存器TMOD时，视频当中出现了一下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TMOD=0x01;</span><br><span class="line">TMOD=TMOD&amp;0xFC;</span><br><span class="line">TMOD=TMOD|0x01;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为TMOD寄存器是不可位寻址的，因此第一句则直接将0x01赋值给TMOD。目的是为了设置TMOD寄存器当中的定时器0为“模式1”，一般情况下我们只需要编写第一句就能设置完了。</p><p>&emsp;&emsp;第二、三两句则是为了使代码更加严谨。事实上，我们在这里只使用定时器0。我们假设此时的定时器1也有被使用，且被设置为其他模式。而我们只需要设置定时器0，倘若直接使用第一句代码来设置TMOD，则会影响到当前定时器1的模式。因此我们需要进行“与或”运算来确保我们更改的只有定时器0的模式。（只使用定时器1的时候同理）</p><p>&emsp;&emsp;在这里就需要用到C语言当中的“与”、“或”这两种逻辑运算的知识了。</p><p>&emsp;&emsp;接下来咱们解释一下第二、三行代码的具体作用，两行代码对数据的处理一共分为两步：</p><p>&emsp;&emsp;第一步：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TMOD=TMOD&amp;0xFC; </span><br><span class="line">/*</span><br><span class="line">0x01 —— 0000 0001</span><br><span class="line">&amp;</span><br><span class="line">0xFD —— 1111 1100</span><br><span class="line">=</span><br><span class="line">0x00 —— 0000 0000</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对当前TMOD的值进行与运算，与上数值0xFC,目的是为了使定时器0的M1和M0这两个位的值为0，为第二步做准备。</p><p>&emsp;&emsp;第二步：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TMOD=TMOD|0x01;</span><br><span class="line">/*</span><br><span class="line">0x00 —— 0000 0000</span><br><span class="line">|</span><br><span class="line">0x01 —— 0000 0001</span><br><span class="line">=</span><br><span class="line">0x01 —— 0000 0001</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;进行或运算，或上数值0x01,目的是为了使定时器0的M1和M0这两个位置的值分别为0和1，即“模式1”。而其他位则恢复为原来的数值。</p><p>&emsp;&emsp;<strong>接下来我们来解释一下这里的“严谨之处”</strong></p><p>&emsp;&emsp;在这里我们假设定时器0和定时器1的模式均被设置为模式1，则：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x10 —— 0001 0000 //一开始寄存器TMOD的状态，此时定时器1为模式1。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们需要执行一下与操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TMOD=TMOD&amp;0xFC；</span><br><span class="line">/*</span><br><span class="line">0x10 —— 0001 0001</span><br><span class="line">&amp;</span><br><span class="line">0xFC —— 1111 1100</span><br><span class="line">=</span><br><span class="line">0x10 —— 0001 0000</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，执行到这里的时候，定时器1的状态被保留了下来，而定时器0的状态则被重置了。</p><p>&emsp;&emsp;接下来我们执行第二步的操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TMOD=TMOD|0x01</span><br><span class="line">/*</span><br><span class="line">0x10 —— 0001 0000</span><br><span class="line">|</span><br><span class="line">0x01 —— 0000 0001</span><br><span class="line">=</span><br><span class="line">0x11 —— 0001 0001</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行到这里可以看出不仅定时器1的状态被保留了下来，定时器0也成功被设置位模式1，这就是只修改对应定时器状态的方法，虽然麻烦了点，但会更加的严谨。</p><h3 id="查询法中断程序实现"><a href="#查询法中断程序实现" class="headerlink" title="查询法中断程序实现"></a>查询法中断程序实现</h3><p><img src="/img/stc/jcq6.png"></p><p>&emsp;&emsp;以上程序当中的第15——17行:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TF0=0； //寄存器内数值“满”了之后标志位需要重新复位</span><br><span class="line"></span><br><span class="line">TH0=0xB1; //寄存器内的数值“满”了之后，寄存器“清零”，需要重新加载初值</span><br><span class="line">TL0=0xF4; //按照之前计算出的20000次，这里的数值应该为0xDF,这里的0xF4可能是算错了</span><br></pre></td></tr></table></figure><h2 id="中断法配置定时器"><a href="#中断法配置定时器" class="headerlink" title="中断法配置定时器"></a>中断法配置定时器</h2><p><img src="/img/stc/zd1.png"></p><p>&emsp;&emsp;在使用中断的时候，中断遵循查询次序，优先级按照上图表格从上至下依次排列。表格当中用红色的框框选起来的几个定时器为常用的定时器，在使用时注意中断源所对应的中断号。</p><p><img src="/img/stc/zd2.png"></p><p><img src="/img/stc/zd3.png"></p><h3 id="中断程序实现"><a href="#中断程序实现" class="headerlink" title="中断程序实现"></a>中断程序实现</h3><p><img src="/img/stc/zd4.png"></p><p>&emsp;&emsp;上图的代码当中出现了这么一行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static unsigned int cnt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的static目的是为了保留延时函数里的cnt变量的值，cnt作为延时函数当中的局部变量，在跳出延时函数时cnt的值会被清除，所以在定义时需要加上“static”这个关键字来保留它的值。</p><h3 id="按键去抖操作的其他方法"><a href="#按键去抖操作的其他方法" class="headerlink" title="按键去抖操作的其他方法"></a>按键去抖操作的其他方法</h3><p>&emsp;&emsp;下图代码属于对上图代码的补充。</p><p><img src="/img/stc/aj1.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(cnt1!=0x00) //这条语句包括了弹起和抖动状态</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模电学习笔记（1）</title>
      <link href="/2021/07/20/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2021/07/20/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><div class="note info flat"><p>模电的学习过程跟随上交大郑益慧老师的<a href="https://www.bilibili.com/video/BV1Gt411b7Zq">模电课程</a></p></div><div class="note info flat"><p>教材采用《模拟电子技术基础（第四版）》华英成、童诗白主编——高等教育出版社</p></div><h1 id="半导体基础"><a href="#半导体基础" class="headerlink" title="半导体基础"></a>半导体基础</h1><h2 id="一、本征半导体"><a href="#一、本征半导体" class="headerlink" title="一、本征半导体"></a>一、本征半导体</h2><p>&emsp;&emsp;本征半导体：指纯净的具有晶体结构的半导体。</p><p>&emsp;&emsp;本征激发：指半导体在热激发下产生自由电子和空穴对的现象。</p><h2 id="二、杂质半导体"><a href="#二、杂质半导体" class="headerlink" title="二、杂质半导体"></a>二、杂质半导体</h2><p>&emsp;&emsp;通过扩散工艺，在本征半导体中掺入少量合适的杂质元素，即可得到杂质半导体。控制掺入杂质元素的浓度，就可以控制杂质半导体的导电性能。</p><h3 id="N型半导体"><a href="#N型半导体" class="headerlink" title="N型半导体"></a>N型半导体</h3><p>&emsp;&emsp;在纯净的硅晶体当中掺入五价元素（如磷），使之取代晶格中硅原子的位置，就形成了N型半导体。事实上，当磷取代了硅的位置后，由于磷原子外层有5个电子，在常温下由于热激发，导致自由电子增多。此时自由电子为多数载流子（多子），空穴成为少数载流子（少子）。杂质原子提供电子，故称为施主电子。</p><p>&emsp;&emsp;N为Negative(负)的字头，由于电子带负电，故称之为N型半导体。</p><h3 id="P型半导体"><a href="#P型半导体" class="headerlink" title="P型半导体"></a>P型半导体</h3><p>&emsp;&emsp;同理，在纯净的硅原子当中掺入三价元素（如硼），使得空穴成为多子，自由电子成为少子。因杂质原子中的空位吸收电子，故称之为受主原子。</p><p>&emsp;&emsp;P为Positive(正)的字头，由于空穴带正电，故称之为P型半导体。</p><h2 id="三、PN结——空间电荷区（耗尽层、阻挡层）"><a href="#三、PN结——空间电荷区（耗尽层、阻挡层）" class="headerlink" title="三、PN结——空间电荷区（耗尽层、阻挡层）"></a>三、PN结——空间电荷区（耗尽层、阻挡层）</h2><p>&emsp;&emsp;PN结：采用不同的掺杂工艺，将以上两种半导体制作在同一块硅片上，在交界面就形成PN结。</p><p>&emsp;&emsp;PN结具有单向导电性。</p><p>&emsp;&emsp;由于浓度差所产生的扩散运动，两种半导体之间的载流子浓度差很大，因此P区空穴向N区扩散，N区自由电子向P区扩散。自由电子与空穴相互复合，在交界处附近的多子浓度下降，P区出现负离子区，N区出现正离子区，由于原子处于晶格当中无法移动，就形成了空间电荷区，从而形成内电场。</p><p>&emsp;&emsp;事实上，当N区的五价元素失去一个电子时，最外层剩下4个电子形成稳定结构，从而形成正离子。同理，当P区的三价元素得到一个电子时，最外层也为4个电子，从而形成负离子，就这样形成了内电场。</p><p>&emsp;&emsp;随着扩散运动的进行，空间电荷区加宽，内电场增强，方向由N区指向P区，正好阻止了扩散运动的进行。</p><p>&emsp;&emsp;多子做扩散运动，而少子穿过空间电荷区的运动被称为漂移运动。（简称：多子扩散，少子漂移。）</p><p>&emsp;&emsp;当两边半导体的掺杂程度相同时，则称这种PN结为<strong>对称结</strong>，相对应的还有<strong>不对称结</strong>。  </p><p>&emsp;&emsp;当二极管受外部的正向电压时（即从P指向N），外电场削弱内电场，二极管正向导通，同理，当二极管受外部的反向电压时（即N指向P）,外电场增强内电场，空间电荷区逐渐变宽，二极管反向截止。</p><h3 id="反向饱和电流"><a href="#反向饱和电流" class="headerlink" title="反向饱和电流"></a>反向饱和电流</h3><p>&emsp;&emsp;事实上去，当二极管受到反向电压时，少子的漂移运动增强，所以还是会产生微安级的电流，由于电流太小几乎可以忽略不计，而这一电流对温度比较敏感，这一电流被称作反向饱和电流。</p><p><img src="/img/modian/ejg/fatxqx.png"></p><p>&emsp;&emsp;上图画的过于理想，事实上在加上反向电压的时候，还存在一部分的反向饱和电流。并不是完全为零。</p><h3 id="PN结的电流方程"><a href="#PN结的电流方程" class="headerlink" title="PN结的电流方程"></a>PN结的电流方程</h3><p><img src="/img/modian/ejg/dlfc.png"></p><h2 id="四、PN结的伏安特性"><a href="#四、PN结的伏安特性" class="headerlink" title="四、PN结的伏安特性"></a>四、PN结的伏安特性</h2><p>&emsp;&emsp;锗管（Ge）的正向导通电压一般为：0.2-0.3V。</p><p>&emsp;&emsp;硅管（Si）的正向导通电压一般为：0.6-0.7V。</p><p>&emsp;&emsp;1、正向特性：死区</p><p>&emsp;&emsp;2、反向特性：反向击穿</p><h3 id="反向击穿"><a href="#反向击穿" class="headerlink" title="反向击穿"></a>反向击穿</h3><p>&emsp;&emsp;E=U/d</p><h4 id="雪崩击穿——掺杂浓度比较低的时候"><a href="#雪崩击穿——掺杂浓度比较低的时候" class="headerlink" title="雪崩击穿——掺杂浓度比较低的时候"></a>雪崩击穿——掺杂浓度比较低的时候</h4><p>&emsp;&emsp;当掺杂浓度比较低的时候，PN结由于反向电压而产生足够的宽度，则PN结则会变成类似与粒子加速器的效果，当自由电子进入PN结之后之后，在场强作用下速度加快，冲击价电子，价电子被冲击后形成自由电子，如此往复。</p><p>&emsp;&emsp;温度越高，雪崩击穿所需要的击穿电压就越高。雪崩击穿所需要的除了一定大的场强，还要有足够的距离供粒子加速。倘若加速的行程足够长，那么所需要的电压（场强）就越低。温度升高后，晶格结构也会开始运动，离子碰上晶格的概率增大，行程变短的概率也会增大。所以更短的距离就需要更大的电压以获取更多的能量。</p><h4 id="齐纳击穿——掺杂浓度比较高的时候"><a href="#齐纳击穿——掺杂浓度比较高的时候" class="headerlink" title="齐纳击穿——掺杂浓度比较高的时候"></a>齐纳击穿——掺杂浓度比较高的时候</h4><p>&emsp;&emsp;掺杂浓度比较高导致场强大，PN结距离短，只需 要很小的电压，直接将价电子从共价键当中拉出。</p><p>&emsp;&emsp;温度越高，齐纳击穿所需要的击穿电压就越低。温度越高，价电子本身的热运动加剧，更容易移动。</p><h4 id="热击穿"><a href="#热击穿" class="headerlink" title="热击穿"></a>热击穿</h4><p>&emsp;&emsp;反向击穿引起PN结温度升高，电流乘以PN结的电压就是PN结消耗的电功率（发热），温度过高导致PN结烧毁</p><h2 id="五、PN结的电容效应"><a href="#五、PN结的电容效应" class="headerlink" title="五、PN结的电容效应"></a>五、PN结的电容效应</h2><p>&emsp;&emsp;如果一个器件，随着电压变化，器件内储存的电量就变化，那么这一器件就表现出一种电容特性。</p><h3 id="势垒电容"><a href="#势垒电容" class="headerlink" title="势垒电容"></a>势垒电容</h3><p>&emsp;&emsp;反向电压逐渐增大，中间的PN结逐渐加宽，加宽的同时电荷量也在增加。这种电容效应发生在势垒当中，因此称之为<strong>势垒电容</strong>。</p><p><img src="/img/modian/ejg/sldr.png"></p><h3 id="扩散电容"><a href="#扩散电容" class="headerlink" title="扩散电容"></a>扩散电容</h3><p>&emsp;&emsp;PN结处于平衡状态时的少子被称之为平衡少子，当PN结处于正向偏置时，从P扩散到N的空穴和从N扩散到P的自由电子均被称为非平衡少子。当外加的正向电压一定时，靠近耗尽层交界面的非平衡少子浓度高，远离耗尽层的非平衡少子浓度低。形成浓度从高至低的浓度梯度（浓度差），从而形成了扩散电流。</p><p><img src="/img/modian/ejg/ksdr.png"></p><p>&emsp;&emsp;扩散区内，电荷的积累和释放过程与电容器充放电过程相同，这种电容效应称为<strong>扩散电容</strong></p>]]></content>
      
      
      <categories>
          
          <category> 模拟电子技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（6）</title>
      <link href="/2021/07/18/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/"/>
      <url>/2021/07/18/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="按键控制"><a href="#按键控制" class="headerlink" title="按键控制"></a>按键控制</h1><div class="note info flat"><p>学习过程跟随up主<a href="https://www.bilibili.com/video/BV1vJ411X7iZ?p=7&t=29">@海创电子</a></p></div><p>&emsp;&emsp;在这之前，我们先看看开发板当中，有关按键的原理图部分。</p><p><img src="/img/stc/aj.png"></p><h2 id="按键动作过程"><a href="#按键动作过程" class="headerlink" title="按键动作过程"></a>按键动作过程</h2><p>&emsp;&emsp;当按键按下时，由于各个按键的另一端接地，单片机的管脚会接受到一个低电平信号。</p><p>&emsp;&emsp;理想情况下，在未按下按钮时，电平信号为高电平，而在按键按下之后，电平信号由高电平变为低电平。</p><p>&emsp;&emsp;而在实际情况下,当按钮按下时，会在高电平与低电平之间产生高低电平的交替现象，这一现象称之为抖动。在抖动现象结束后才会呈现出稳定的低电平，随着按键抬起时抖动现象再次出现，直至现象结束后回到高电平状态。</p><p><img src="/img/stc/ajdd.png"></p><h2 id="实现按键动作"><a href="#实现按键动作" class="headerlink" title="实现按键动作"></a>实现按键动作</h2><h3 id="按键动作流程"><a href="#按键动作流程" class="headerlink" title="按键动作流程"></a>按键动作流程</h3><p>&emsp;&emsp;如果要实现按键动作，需要先检测到低电平动作，检测到低电平动作之后，使用延时函数延时5ms。这里延时5ms是因为抖动现象开始到结束时间一般为5ms,延时过后相当于跳过抖动。之后再次检测是否为低电平，若为低电平则执行相应动作。</p><p>&emsp;&emsp;“去抖”操作除了用软件可以实现，在硬件上也可以实现，这里讲的是使用软件去抖的方式。</p><h3 id="程序实现——用按钮控制LED灯的亮灭"><a href="#程序实现——用按钮控制LED灯的亮灭" class="headerlink" title="程序实现——用按钮控制LED灯的亮灭"></a>程序实现——用按钮控制LED灯的亮灭</h3><p>&emsp;&emsp;这里控制LED的按钮是常见的按键开关，动作只有单纯的按下和弹起两种。这里我们选用if类型语句作逻辑判断。</p><h4 id="“if”语句"><a href="#“if”语句" class="headerlink" title="“if”语句"></a>“if”语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KEY == 0)</span><br><span class="line">&#123;</span><br><span class="line">delay(5);      //延时5ms</span><br><span class="line"><span class="keyword">if</span>(KEY == 0)</span><br><span class="line">&#123;</span><br><span class="line">LED=~LED;  //LED取反操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!KEY);   //判断按键是否松开</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p><a href="http://www.51hei.com/mcu/1869.html">while(!KEY);的具体作用</a></p></div><p>&emsp;&emsp;“while(!KEY);”语句起到了判断按键状态的作用。若按键未释放，则KEY=0，那么!KEY=1,while语句就一直处于循环状态。同理，当按键松开时则跳出while语句循环。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（5）</title>
      <link href="/2021/07/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/"/>
      <url>/2021/07/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="端口的使用"><a href="#端口的使用" class="headerlink" title="端口的使用"></a>端口的使用</h1><h2 id="端口初始化"><a href="#端口初始化" class="headerlink" title="端口初始化"></a>端口初始化</h2><div class="note info flat"><p>注意：以下文章所使用的单片机为IAP15W4K58S4</p></div><p>&emsp;&emsp;在上一篇文章当中，我们介绍了编写程序控制单片机以实现流水灯的几种方法。</p><p>&emsp;&emsp;在最后一种方法当中，出现了这样的几行代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">P0M0=0X00;P0M1=0X00;   //这里对I/O口进行初始化</span><br><span class="line">P1M0=0X00;P1M1=0X00;</span><br><span class="line">P2M0=0X00;P2M1=0X00;</span><br><span class="line">P3M0=0X00;P3M1=0X00;</span><br><span class="line">P4M0=0X00;P4M1=0X00;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;相关的内容在&lt;STC15.h&gt;这个头文件当中已有详细说明：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfr P0M0        =   0x94;   //0000,0000 端口0模式寄存器0</span><br><span class="line">sfr P0M1        =   0x93;   //0000,0000 端口0模式寄存器1</span><br><span class="line">sfr P1M0        =   0x92;   //0000,0000 端口1模式寄存器0</span><br><span class="line">sfr P1M1        =   0x91;   //0000,0000 端口1模式寄存器1</span><br><span class="line">sfr P2M0        =   0x96;   //0000,0000 端口2模式寄存器0</span><br><span class="line">sfr P2M1        =   0x95;   //0000,0000 端口2模式寄存器1</span><br><span class="line">sfr P3M0        =   0xB2;   //0000,0000 端口3模式寄存器0</span><br><span class="line">sfr P3M1        =   0xB1;   //0000,0000 端口3模式寄存器1</span><br><span class="line">sfr P4M0        =   0xB4;   //0000,0000 端口4模式寄存器0</span><br><span class="line">sfr P4M1        =   0xB3;   //0000,0000 端口4模式寄存器1</span><br><span class="line">sfr P5M0        =   0xCA;   //0000,0000 端口5模式寄存器0</span><br><span class="line">sfr P5M1        =   0xC9;   //0000,0000 端口5模式寄存器1</span><br><span class="line">sfr P6M0        =   0xCC;   //0000,0000 端口6模式寄存器0</span><br><span class="line">sfr P6M1        =   0xCB;   //0000,0000 端口6模式寄存器1</span><br><span class="line">sfr P7M0        =   0xE2;   //0000,0000 端口7模式寄存器0</span><br><span class="line">sfr P7M1        =   0xE1;   //0000,0000 端口7模式寄存器1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码在STC的官方资料当中有介绍，根据资料介绍，每一个i/o口由2个控制寄存器中的相应位控制每个引脚工作类型。</p><p> <img src="/img/stc/io.png"></p><div class="note info flat"><p>注意：该图片来自文章<a href="https://blog.csdn.net/qq_28145393/article/details/117751988">关于STC15系列的IO口如何配置—简单易懂超详细</a></p></div><h2 id="I-O口的四种工作类型"><a href="#I-O口的四种工作类型" class="headerlink" title="I/O口的四种工作类型"></a>I/O口的四种工作类型</h2><p>&emsp;&emsp;STC15单片机最多拥有62个I/O口，相对应的，每个I/O口都有四种工作方式。分别是：准双向口、推挽输出、高阻输入和开漏。</p><p>&emsp;&emsp;具体的概念介绍可以参考以下几篇文章：</p><div class="note info flat"><p><a href="https://blog.csdn.net/techexchangeischeap/article/details/72569999">GPIO输入输出各种模式（推挽、开漏、准双向端口）详解</a></p></div><div class="note info flat"><p><a href="https://blog.csdn.net/weixin_45367147/article/details/106077528">STC15单片机I/O口的四种模式</a></p></div><div class="note info flat"><p><a href="https://blog.csdn.net/qq_28145393/article/details/117751988">关于STC15系列的IO口如何配置—简单易懂超详细</a></p></div><div class="note info flat"><p><a href="https://www.sohu.com/a/206866193_505888">单片机IO口科普：推挽输出、开漏输出详解</a></p></div><p>&emsp;&emsp;欸，其实就是我模电学的不好，本来还想细讲的，结果发现根本看不懂这几篇文章。所以这个知识点先放在这里，等我哪天把模电的坑补回来了再细说这四个工作模式。</p><p>&emsp;&emsp;真是歪了个比巴卜的……</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（4）</title>
      <link href="/2021/07/11/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
      <url>/2021/07/11/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="单片机学习笔记之LED流水灯"><a href="#单片机学习笔记之LED流水灯" class="headerlink" title="单片机学习笔记之LED流水灯"></a>单片机学习笔记之LED流水灯</h1><div class="note info flat"><p>学习过程跟随B站up主<a href="https://www.bilibili.com/video/BV1vJ411X7iZ?p=5&t=1135">@海创电子</a></p></div><p>&emsp;&emsp;这里我们采用的开发板是大科电子工作室的FM-STC15开发板。</p><p>&emsp;&emsp;LED部分的原理图如下：</p><p> <img src="/img/stc/FM-5-LED.png"></p><p>&emsp;&emsp;在开发板上实现流水灯，必须先了解开发板上的LED小灯是如何排列的。上图的LED小灯显然是属于“共阳”（即LED的“阳级”连在一起）。与之相反，也有的开发板上的LED小灯是属于“共阴”的，这时我们就需要判断LED灯的亮灭是需要高电平还是低电平，这与接下来编程时的“0”和“1”是有关系的。</p><p>&emsp;&emsp;在单片机学习笔记（2）当中，我简单的介绍了关于利用单片机简单实现LED的亮灭，今天我们来学习如何制作流水灯。</p><h2 id="方法1：利用十六进制数来制作流水灯"><a href="#方法1：利用十六进制数来制作流水灯" class="headerlink" title="方法1：利用十六进制数来制作流水灯"></a>方法1：利用十六进制数来制作流水灯</h2><p>&emsp;&emsp;具体代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;STC15.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;intrins.h&gt;    /*intrins.h，函数，应用于程序设计，一般出现于C51单片机编程中，一般程序中需要使用到空指令_nop_(),</span></span><br><span class="line">                          字符循环移位指令_crol_等时使用。*/</span><br><span class="line"><span class="comment">#define LED P0          //用“define”语句来表示常量，即将&quot;LED&quot;定义为P0端口。</span></span><br><span class="line">void delay();</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">&#123;</span><br><span class="line">LED=0xFE;      //这里使用了十六进制数来表示，对P0这个io口进行了统一的定义。</span><br><span class="line">delay();       //之后就是使用延时函数来实现灯交换闪烁的间隔时间。</span><br><span class="line">LED=0xFD;</span><br><span class="line">delay();</span><br><span class="line">LED=0xFB;</span><br><span class="line">delay();</span><br><span class="line">LED=0xF7;</span><br><span class="line">delay();</span><br><span class="line">LED=0xEF;</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void <span class="function"><span class="title">delay</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i,g;</span><br><span class="line">_nop_();              /*这里使用“_nop_()”空指令的目的也是为了延时，</span><br><span class="line">_nop_();                程序运行到这里会出现一定的时间间隔且不做任何操作。</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;300;i++)      使用时需要先声明头文件“&lt;intrins.h&gt;”*/</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(g=0;g&lt;1000;g++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：利用“for”循环语句实现流水灯"><a href="#方法2：利用“for”循环语句实现流水灯" class="headerlink" title="方法2：利用“for”循环语句实现流水灯"></a>方法2：利用“for”循环语句实现流水灯</h2><p>&emsp;&emsp;代码大同小异，不同的是在“while”循环语句当中采用“for”循环语句，并且使用了位移取反的操作，略微麻烦，相关代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int k;</span><br><span class="line"><span class="keyword">for</span>(k=0;k&lt;8;k++)</span><br><span class="line">&#123;</span><br><span class="line">LED=~(0x01&lt;&lt;<span class="string">k);   //“&lt;&lt;”运算符做位移操作，表示数值向左位移。</span></span><br><span class="line"><span class="string">delay();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;“~”作为取反符号，在“for”循环语句执行时，初始的十六进制数为“00000001”，由于第一次循环时k的值为0，所以不作位移操作，最后得到的十六进制数也是“00000001”。在第二次循环的时候，k的值为1，数值向左位移一位，即“00000010”，此时第二个灯开始亮，以此类推。</p><h2 id="方法3：利用数组来实现流水灯"><a href="#方法3：利用数组来实现流水灯" class="headerlink" title="方法3：利用数组来实现流水灯"></a>方法3：利用数组来实现流水灯</h2><p>&emsp;&emsp;同样的，使用数组也可以实现流水灯，代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unsigned char code table[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;</span><br><span class="line">//定义一个数组，数组内容则为十六进制数</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">P0M0=0X00;P0M1=0X00;</span><br><span class="line">//这里对I/O口进行初始化</span><br><span class="line"></span><br><span class="line">P1M0=0X00;P1M1=0X00;</span><br><span class="line">P2M0=0X00;P2M1=0X00;</span><br><span class="line">P3M0=0X00;P3M1=0X00;</span><br><span class="line">P4M0=0X00;P4M1=0X00;</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">&#123;</span><br><span class="line">P0=table[0];        /*依次输出数组内的内容</span><br><span class="line">delay();              也可以尝试采用“<span class="keyword">for</span>”循环</span><br><span class="line">P0=table[1];          遍历数组的方法来实现流水灯*/</span><br><span class="line">delay();</span><br><span class="line">P0=table[2];</span><br><span class="line">delay();</span><br><span class="line">P0=table[3];</span><br><span class="line">delay();</span><br><span class="line">P0=table[4];</span><br><span class="line">delay();</span><br><span class="line">P0=table[5];</span><br><span class="line">delay();</span><br><span class="line">P0=table[6];</span><br><span class="line">delay();</span><br><span class="line">P0=table[7];</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小技巧：在数组当中插入“标志数”进行循环"><a href="#小技巧：在数组当中插入“标志数”进行循环" class="headerlink" title="小技巧：在数组当中插入“标志数”进行循环"></a>小技巧：在数组当中插入“标志数”进行循环</h2><p>&emsp;&emsp;同样的，在循环语句当中使用数组时，可以采用这样的写法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;STC15.h&gt;</span></span><br><span class="line">unsigned char</span><br><span class="line">LedChar[]=&#123;0xEF,0xDF,0xBF,0x7F,0xEE,0xDD,0x21,0x12,0x00&#125;;</span><br><span class="line">void delay();</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(1)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i=0;</span><br><span class="line"><span class="keyword">while</span>(LedChar[i]!=0x00)</span><br><span class="line">&#123;</span><br><span class="line">P0=LedChar[i];</span><br><span class="line">delay();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void <span class="function"><span class="title">delay</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">*********</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在数组当中的“0x00”就是所谓的标志数，当数组循环到“0x00”时，程序执行到while内的判断，循环就会跳出，这样的写法相对于单纯的使用for语句会简单很多。在习惯上不在数组名后面填写元素个数的话，这个方法也可以巧妙的让循环跳出。</p><p>&emsp;&emsp;注意，“标志数”作为标志作用，不应与数组内的其他元素相同。</p><h1 id="C语言知识穿插——有参延时函数"><a href="#C语言知识穿插——有参延时函数" class="headerlink" title="C语言知识穿插——有参延时函数"></a>C语言知识穿插——有参延时函数</h1><p>&emsp;&emsp;一般来说，延时函数延时的时间为1秒，如果延时的时间较长，我们可以将原来的延时函数进行改写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void delay(unsigned int j)   //这里的“j”是形式参数</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i,j;</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;183;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=0;k&lt;j;k++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在使用上只需改变函数括号内的数值即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dalay(1000);     //括号内的称之为“实际参数”</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，在使用时需要在主函数的前面修改函数声明：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void delay(unsigned int j);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总结一句话就是在延时函数当中加入参数，通过改变参数的数值来实现对延时函数时间的控制。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（4）</title>
      <link href="/2021/03/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
      <url>/2021/03/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="关于char类型"><a href="#关于char类型" class="headerlink" title="关于char类型"></a>关于char类型</h2><p>&emsp;&emsp;我们先从一道编程题开始讲起。</p><div class="note info flat"><p>编程实现字母的大小写转换,要求从键盘输入任意大写字母,程序转换成小写字母并输出。</p></div><p>&emsp;&emsp;这是今天在上C语言课的时候，老师在课上布置的随堂练习。我自己一开始是打算用if判断来实现，但是非常的明显————使用逻辑判断语句来实现这个题目既复杂，又显的……emmm，有点蠢。所以我就“稍微”百度了一下。这里贴出这位老哥的做法：<br><a href="https://blog.csdn.net/qq_40757240/article/details/86552740">C语言实验题――大小写转换 从键盘输入一个大写字母，要求改用小写字母输出。</a></p><p>&emsp;&emsp;为了方便查看和说明，我将上面链接当中的代码展示在下方。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">ch=getchar();</span><br><span class="line">//这里并没有检验这个是不是字母</span><br><span class="line">putchar(ch+32);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="初识char"><a href="#初识char" class="headerlink" title="初识char"></a>初识char</h3><p>&emsp;&emsp;先简单说明一下，char属于C语言当中的一种常见的数据类型，即字符类型。</p><p>&emsp;&emsp;以下文字取于书本原文：</p><div class="note info flat"><p>“字符类型包含字母、数字、标点符号以及控制符号等，在内存当中是以整数数值的方式来存储的，每一个字符占用1个字节（8个二进制位）的数据长度，所以字符ASCII编码的数值范围在0~127之间。例如字符‘A’的数值为65、字符‘0’的数值为48。”</p></div><p>&emsp;&emsp;其实说白了，char类型就负责在C语言当中对字符的处理。字符类型也有char、signed char和unsigned char这三种。</p><h3 id="char的使用"><a href="#char的使用" class="headerlink" title="char的使用"></a>char的使用</h3><p>&emsp;&emsp;在C语言当中使用char时，需要这样表达。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char ch=<span class="string">&#x27;a&#x27;</span> //声明ch为字符变量，并设置初始值为<span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>&emsp;这一语句的意思是在声明一个字符变量，变量的名字为“ch”,它被设置的初始值为a。</p><div class="note danger flat"><p>注意：在为字符变量赋值的时候，使用的是单引号<mark class="hl-label @''">info</mark> ，而不是双引号&lt;mark class=”hl-label @”””&gt;danger</mark> !</p></div><p>&emsp;&emsp;在赋值的时候，除了直接使用字符，我们也可以利用ASCII码赋值，例如上面那一行我们还可以写成如下形式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char ch=65; //声明ch为字符变量，并设置初始值为65</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然了，同理，我们还可以这样来表示字符。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char text=<span class="string">&#x27;\x41&#x27;</span>; //十六进制ASCII码表示 A 字符</span><br><span class="line">char text=0x41; //十六进制数值表示 A 字符</span><br><span class="line">char text=<span class="string">&#x27;\101&#x27;</span>; //八进制ASCII码表示 A 字符</span><br><span class="line">char text=0101; //八进制数值表示 A 字符</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>注意：在使用ASCII码或者进制数进行赋值时，语句结尾需要加上<mark class="hl-label @;">info</mark> </p></div><h2 id="字符类型当中的其他函数"><a href="#字符类型当中的其他函数" class="headerlink" title="字符类型当中的其他函数"></a>字符类型当中的其他函数</h2><h3 id="关于getchar-函数"><a href="#关于getchar-函数" class="headerlink" title="关于getchar()函数"></a>关于getchar()函数</h3><p>&emsp;&emsp;接下来我们就回到一开始那个老哥的例程上。在例程当中，我们可以看见这几条语句：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ch=getchar();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这条语句当中出现了<mark class="hl-label @getchar()">info</mark> 这个函数，这个函数在C语言当中的作用是从计算机终端（一般为键盘）获取一个无符号字符。getchar()函数只能接收一个字符，其函数值就是从输入设备获取到的字符。<a href="https://baike.baidu.com/item/getchar%28%29/6876946?fr=aladdin">getchar()——百度百科</a></p><h3 id="关于putchar-函数"><a href="#关于putchar-函数" class="headerlink" title="关于putchar()函数"></a>关于putchar()函数</h3><p>&emsp;&emsp;同时我们在例程当中出现了这条语句：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">putchar(ch+32);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这条语句当中出现了<mark class="hl-label @putchar()">info</mark> 这个函数，这个函数的作用是把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。</p><p>&emsp;&emsp;除此之外，我们还看见在括号里面出现<mark class="hl-label @ch+32">info</mark> 。</p><p>&emsp;&emsp;字符可以通过ASCII码进行四则运算：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,100+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,100-<span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于字符A的ASCII码为65，所以上面的运算出来的结果分别为165与35。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（3）</title>
      <link href="/2021/01/17/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
      <url>/2021/01/17/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="单片机学习之——运算符"><a href="#单片机学习之——运算符" class="headerlink" title="单片机学习之——运算符"></a>单片机学习之——运算符</h1><p>&emsp;&emsp;在了解完一些数据类型之后，接下来我们将学习如何使用运算符。</p><p>&emsp;&emsp;视频传送门：<a href="https://www.bilibili.com/video/BV15Q4y1K7Kg">C51单片机编程基础-运算符</a></p><h2 id="一、C51中常见的运算符"><a href="#一、C51中常见的运算符" class="headerlink" title="一、C51中常见的运算符"></a>一、C51中常见的运算符</h2><p>&emsp;&emsp;在C51当中，除了在C语言当中常见的运算符，还有一些之前接触较少的运算符，例如：</p><div class="note info flat"><p>算数运算符：++<br>位运算符：&amp; | ^ ~ &lt;&lt; &gt;&gt;<br>逻辑运算符：&amp;&amp; || ！<br>三目录运算符：con?ture:false</p></div><h2 id="二、运算符用法"><a href="#二、运算符用法" class="headerlink" title="二、运算符用法"></a>二、运算符用法</h2><p>&emsp;&emsp;这里我们针对一些运算符进行说明：</p><h3 id="1、算数运算符：-（自增）"><a href="#1、算数运算符：-（自增）" class="headerlink" title="1、算数运算符：++（自增）"></a>1、算数运算符：++（自增）</h3><p>&emsp;&emsp;我们先看下面的示例代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int a=10 ,b;</span><br><span class="line">b=++a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>,a,b);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码当中的<mark class="hl-label @b=++a">primary</mark> 的运算顺序是先进行运算，再进行赋值。即：</p><div class="note info flat"><p>a=11<br>b=11</p></div><p>&emsp;&emsp;若是将语句<mark class="hl-label @b=++a">primary</mark> 改为<mark class="hl-label @b=a++">primary</mark> 则是先进行赋值，再进行运算，即：</p><div class="note info flat"><p>a=10<br>b=11</p></div><h3 id="2、逻辑运算符：-amp-amp-（逻辑与）"><a href="#2、逻辑运算符：-amp-amp-（逻辑与）" class="headerlink" title="2、逻辑运算符：&amp;&amp;（逻辑与）"></a>2、逻辑运算符：&amp;&amp;（逻辑与）</h3><p>&emsp;&emsp;逻辑与运算遵循：“有0为0”</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（2）</title>
      <link href="/2021/01/16/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
      <url>/2021/01/16/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="单片机学习之——C51初识"><a href="#单片机学习之——C51初识" class="headerlink" title="单片机学习之——C51初识"></a>单片机学习之——C51初识</h1><p>&emsp;&emsp;在搞清楚进制转换之后，接下来就正式进入C51单片机的学习了，在学习的过程中会穿插一些关于C语言的一些知识，毕竟C51本身就是C语言的一种衍生与应用。接下来我将会按照哔哩哔哩上找的视频教程针对C51进行逐步的学习。</p><p>&emsp;&emsp;视频传送门：<a href="https://www.bilibili.com/video/BV1TA411b7bJ">C51单片机编程基础-变量</a></p><h2 id="一、C51的头文件"><a href="#一、C51的头文件" class="headerlink" title="一、C51的头文件"></a>一、C51的头文件</h2><p>&emsp;&emsp;我们先从程序框架来了解C51程序。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;reg51.h&gt;   //头文件</span></span><br><span class="line">int main(void)      //主函数，main函数</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的头文件分别有两种类型，一种是带有尖括号的叫做系统头文件，另一种是带有双引号的叫做自定义头文件。即：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;reg51.h&gt;           //系统头文件</span><br><span class="line"><span class="string">&quot;head.h&quot;</span>            //自定义头文件</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这意味着未来我们可以编写自己的头文件以用于我们自己写的程序。</p><h2 id="二、C51当中的数据类型"><a href="#二、C51当中的数据类型" class="headerlink" title="二、C51当中的数据类型"></a>二、C51当中的数据类型</h2><p>&emsp;&emsp;C语言当中常见的数据类型有以下几类：</p><div class="note info flat"><p>char                字符型<br>int                 整型<br>long                长整型<br>float               单精度浮点型<br>double              双精度浮点型<br>unsigned char       无符号字符型<br>unsigned int        无符号整型<br>unsigned long       无符号长整型</p></div><p>&emsp;&emsp;然而在C51当中则还有以下几种常见的数据类型：</p><div class="note info flat"><p>sfr                 特殊功能寄存器<br>sfr16               16位特殊功能寄存器<br>bit                 位类型<br>sbit                可寻址位</p></div><p>&emsp;&emsp;例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfr P0 = 0x80;      //定义P0为P0端口在片内的寄存器，P0端口地址为80H</span><br><span class="line">sfr P0 = 0x90;      //定义P1为P1端口在片内的寄存器，P1端口地址为90H</span><br><span class="line"></span><br><span class="line">sbit P1_1 = P1^1;   //P1_1为P1中的P1.1引脚</span><br><span class="line">                    //这样在以后的程序语句中就可以用P1_1来对P1.1引脚进行读写操作</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在了解完前面的内容之后，我们可以通过一个简单的案例来实际应用一下。</p><p>&emsp;&emsp;例题：简单地实现灯的亮灭。</p><p>&emsp;&emsp;具体的代码过程如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;STC15.h&gt;       //和C语言一样，在程序的开头引入STC15单片机的头文件。</span></span><br><span class="line">sbit LED=P0^0;          /*这里的“sbit”语句叫做“位定义”，即把单片机上的P0.0端口使用“LED”来表示。</span><br><span class="line">                          应当需要注意的是，当定义io口的时候，“P”为大写字母，否则编译器会报错。*/</span><br><span class="line">void delay();           /*请注意，这里的“delay”是延时函数，其目的是为了实现在LED灯亮灭间的时间间隔。</span><br><span class="line">                          由于“main”这一主函数放在程序的最前面，当把自定义函数放在“main”函数后面时，</span><br><span class="line">                          需要在“main”函数的前面添加该函数的声明。*/</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(1)            //while旁边的括号当中为非0实数表示该循环语句为无限循环。</span><br><span class="line">&#123;</span><br><span class="line">LED=0;          //这里的“0”或者“1”需要查看原理图，“0”与“1”则代表高低电平，从而点亮LED灯。</span><br><span class="line">delay();</span><br><span class="line">LED=1;</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void <span class="function"><span class="title">delay</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i,g;    /*这里定义了两个无符号的整型变量，在定义变量的时候请注意数字相对应的大小,</span><br><span class="line">                       否则会产生数据溢出，也不必给予过多的内存空间，适量即可。*/</span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;183;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(g=0;g&lt;1000;g++);    //这个“<span class="keyword">for</span>”语句请看下面的讲解。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码当中出现了这么一段“奇怪”的代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(g=0;g&lt;1000;g++);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实这一段代码是下面这段代码的缩写：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foe(g=0;g&lt;1000;g++)</span><br><span class="line">&#123;</span><br><span class="line">;       //这里只有分号，表示这里是一段空代码。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;“delay”函数在执行的时，程序执行“for”语句的嵌套循环，由代码可知，该“delay”函数将空代码执行了183000次。执行这一代码的时间刚刚好满足1秒，从而实现对LED灯亮灭的控制。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单片机学习笔记（1）</title>
      <link href="/2021/01/16/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2021/01/16/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="单片机学习之——二进制与十六进制的互相转换"><a href="#单片机学习之——二进制与十六进制的互相转换" class="headerlink" title="单片机学习之——二进制与十六进制的互相转换"></a>单片机学习之——二进制与十六进制的互相转换</h1><p>&emsp;&emsp;经过一段时间的学习，终于把C语言的基础知识都大致过了一遍，接下来我将会进入单片机的学习。在这过程中偶尔会穿插一些C语言的知识，也算是一边学习单片机，一边复习C语言啦！</p><h2 id="十六进制数"><a href="#十六进制数" class="headerlink" title="十六进制数"></a>十六进制数</h2><h3 id="一、关于十六进制数"><a href="#一、关于十六进制数" class="headerlink" title="一、关于十六进制数"></a>一、关于十六进制数</h3><p>&emsp;&emsp;首先要先知道<a href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/4162457?fr=aladdin">十六进制</a>是什么并且如何表示。</p><p>&emsp;&emsp;一般来说，十六进制由数字0到9和字母A到F（或a到f）来表示。其中A到F依次表示数字10到15依次排开即：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，这些都称之为十六进制数。</p><h3 id="二、十六进制数与二进制数的关系"><a href="#二、十六进制数与二进制数的关系" class="headerlink" title="二、十六进制数与二进制数的关系"></a>二、十六进制数与二进制数的关系</h3><p>&emsp;&emsp;在十六进制的世界里，一个十六进制数字会等于四个二进制数字。</p><p>&emsp;&emsp;如下所示：</p><div class="note info flat"><p>0 –&gt; 0000<br>1 –&gt; 0001<br>2 –&gt; 0010<br>3 –&gt; 0011<br>4 –&gt; 0100<br>5 –&gt; 0101<br>6 –&gt; 0110<br>7 –&gt; 0111<br>8 –&gt; 1000<br>9 –&gt; 1001<br>A –&gt; 1010<br>B –&gt; 1011<br>C –&gt; 1100<br>D –&gt; 1101<br>E –&gt; 1110<br>F –&gt; 1111</p></div><p>&emsp;&emsp;在上方的一组数当中，左侧为二进制数字，右侧为十六进制数。对于右侧的二进制数而言，从右往左看，每一位所表示的大小依次为：1、2、4、8</p><p>&emsp;&emsp;而在右侧的二进制数字当中的“0”与“1”则代表了物理上的开与关，由此可见针对单片机的编程事实上是需要在硬件底层具有一定的理解。在一个开发板上的单片机程序，在其他型号的开发板上就并不适用了。</p><h2 id="二进制转换为"><a href="#二进制转换为" class="headerlink" title="二进制转换为"></a>二进制转换为</h2>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（3）</title>
      <link href="/2020/12/13/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
      <url>/2020/12/13/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>&emsp;&emsp;今天再说说新的东西吧！</p><h2 id="一、关于switch函数的使用"><a href="#一、关于switch函数的使用" class="headerlink" title="一、关于switch函数的使用"></a>一、关于switch函数的使用</h2><p>&emsp;&emsp;同样的，让我们先看一看示例代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">   int a,b;</span><br><span class="line">   char c;</span><br><span class="line">   scanf(<span class="string">&quot;%d&quot;</span>,&amp;a); </span><br><span class="line">   scanf(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">   scanf(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">   switch(c) </span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">case</span><span class="string">&#x27;+&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b); <span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="string">&#x27;-&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a - b); <span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="string">&#x27;*&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a * b); <span class="built_in">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="string">&#x27;/&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span>(a == 0)</span><br><span class="line">&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Divided by zero!&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a / b);<span class="built_in">break</span>;</span><br><span class="line">default : <span class="built_in">printf</span>(<span class="string">&quot;Invalid operator!&quot;</span>); <span class="built_in">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码有用switch语句和if……else判断语句的嵌套复合，这里我们只讨论switch语句功能。</p><p>&emsp;&emsp;“switch”是开关的意思，大致框架如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式:语句块;//这里的语句块是指类似于“<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a)”这样的句子</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">……//这里的省略号表示可以反复循环3和4语句</span><br><span class="line">default: 语句块；</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的<code>case</code>之后的语句将作为判断的条件，当碰到<code>break;</code>时，程序将跳过之后语句块，也就是说，程序在运行过程中会与每一个“case”语句的条件进行判定。若没有遇到符合条件，则会继续执行程序。就算匹配到符合条件，如果没有遇到“break”，则继续执行程序，反之则跳出“seitch”语句判断，即<code>break;</code>以下语句不执行。</p><p>&emsp;&emsp;当然了，当所有<code>case</code>都不满足相应的条件时，那么计算机则会执行<code>default</code>中的代码。</p><p>&emsp;&emsp;<code>default</code>称为“缺省值”。在switch语句当中可有可无，执行到后面的“break”时跳出switch判断。</p><p>&emsp;&emsp;这里推荐一篇文章，讲的更为细致：<a href="http://c.biancheng.net/view/310.html">switch语句用法注意事项，如何正确使用switch语句？</a></p><h2 id="二、关于平方根的计算"><a href="#二、关于平方根的计算" class="headerlink" title="二、关于平方根的计算"></a>二、关于平方根的计算</h2><p>&emsp;&emsp;虽然在上上期我介绍了两种在C语言中次方计算的方法，但是今天还是要补充一下另一种平方根的计算方式。</p><p>&emsp;&emsp;sprt函数可用于在C语言计算一个非负实数的平方，在使用的过程中同样的用如下形式。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sprt(<span class="string">&quot;在此处填入相应的变量名&quot;</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;今天就说到这儿吧……明天再说。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（2）</title>
      <link href="/2020/12/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
      <url>/2020/12/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>&emsp;&emsp;今天的心得并不多，但是我还是觉得很有必要记录一下。</p><h2 id="一、一个数的n次方是属于double型的"><a href="#一、一个数的n次方是属于double型的" class="headerlink" title="一、一个数的n次方是属于double型的"></a>一、一个数的n次方是属于double型的</h2><h2 id="二、使用if……else-if……else语句作逻辑判断"><a href="#二、使用if……else-if……else语句作逻辑判断" class="headerlink" title="二、使用if……else if……else语句作逻辑判断"></a>二、使用if……else if……else语句作逻辑判断</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int a,b,max;</span><br><span class="line">scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">max=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">max=b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;两个数字相等&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码目的是比较两个整数的大小，首先输入两个整数值，从上面的<code>if(a&gt;b)</code>就开始了if判断。其中这段代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">max=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是先判断a与b哪一个大，当a大于b的时候，max这个变量名的数值就会等于a的数值，然后就会把a的值作为最大值输出。这里说明一下，max是在上面就定义的一个变量名，顾名思义是用来存储最大值的。</p><p>&emsp;&emsp;让我们看看下一段代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">max=b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这段代码中，<code>lese if</code>是指当<code>if(&quot;这里是表达式&quot;)</code>也就是if之后的括号里的条件不成立的时候，此时计算机会进行下一步的判断，会判断else if之后的括号里的条件是否成立。在上面的代码中，当a小于b时，接下来计算机就会做出如上判断。当b&gt;a时，b的数值会被赋予max,然后就会把b的值作为最大值输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;两个数字相等&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的这段代码是当if以及else if两次判断都无法判断出结果，只剩下唯一的可能性时，所做出的最后判断。众所周知，两个数字比较大小一共有三种情况：</p><p>&emsp;&emsp;a&gt;b<br>&emsp;&emsp;a&lt;b<br>&emsp;&emsp;a=b</p><p>&emsp;&emsp;同样的，我们先看一下示例代码：在示例代码中，if和else if两个语句分别将a&gt;b和b&gt;a两种情况都讨论完了，只剩下a=b的条件尚未讨论，此时else语句后面就不用加此判定条件。因为计算机会默认认为else的判断条件就是剩下的最后的一个可能性。</p><p>&emsp;&emsp;所以最后一段代码的意思是，当a=b时，将直接输出printf函数中的“两个数字相等”。</p><h2 id="三、if判断语句中“-”的使用"><a href="#三、if判断语句中“-”的使用" class="headerlink" title="三、if判断语句中“=”的使用"></a>三、if判断语句中“=”的使用</h2><p>&emsp;&emsp;同样的，我们先看一下示例代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int N;</span><br><span class="line">scanf(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line"><span class="keyword">if</span>(N&gt;0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;positive&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(N==0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的这段代码目的是判断“N”这个数字的正负性。细心的同学会看见在这段代码中有这样一个现象：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(N==0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的这段代码中，你会发现在<code>else if(N==0)</code>里面，“N”的后面有两个等于号。这里强调一下，在if语句作等于判断的时候，需要在括号里填上两个等于号。这段语句所要判断的是“N”会不会等于“0”，如果等于，则输出printf函数里的“zero”。具体为什么要加两个“=”呢？可以理解为把“=”的赋值功能与之区别。如果将“N”后面的“=”缩减为一个，那么计算机则会认为你将N赋值为0，即N=0。</p><p>&emsp;&emsp;今天就写到这儿，明天再说吧！</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记(1)</title>
      <link href="/2020/12/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2020/12/11/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>&emsp;&emsp;今天谈谈在学习C语言的时候碰到的一些问题，这里在博客上做一点简单的记录。</p><h2 id="一、关于scanf函数"><a href="#一、关于scanf函数" class="headerlink" title="一、关于scanf函数"></a>一、关于scanf函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scanf();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在使用Scanf函数的时候，遇到输入空格、回车、Tab键时，都是默认当前的字符输入结束，此时电脑并不会将以上的三种情况算作你输入的值。这里要多说一句，如果你发现程序运行结束之后，返回的结果是空值（也就是啥都没有），那就要先检查一下你的scanf里面的变量名，前面有没有加上“&amp;”（取地址符）。</p><p>&emsp;&emsp;在使用scanf语句需要在输入时加入提示文字时，需要在scanf的前面用printf语句输出相关的提示语句。因为在c语言当中，scanf语句的功能规定为将用户输入的数值、字符或者字符串传送给相应的变量。</p><h2 id="二、关于C语言中的次方运算"><a href="#二、关于C语言中的次方运算" class="headerlink" title="二、关于C语言中的次方运算"></a>二、关于C语言中的次方运算</h2><p>&emsp;&emsp;首先要说明的是，在C语言中作乘法计算，计算机不识别“ ^ ”运算符。下面介绍两种常见的次方运算方式：</p><h3 id="1、调用math-h头文件，利用pow-函数解决"><a href="#1、调用math-h头文件，利用pow-函数解决" class="headerlink" title="1、调用math.h头文件，利用pow()函数解决"></a>1、调用math.h头文件，利用pow()函数解决</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;math.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">scanf(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">b=pow(a,2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面那一行代码主要目的是计算你输入的“a”的平方。在上面的代码块当中，我们定义了两个整型变量a和b。当程序运行至<code>scanf(&quot;%d&quot;,&amp;a)</code>时,我们在程序框内输入一个数，计算机会把该数的值赋予a，使得a会等于我们输入的数值。此时程序运行下一步，pow函数就是用来计算a的平方，并且将结果赋予b,最后输出结果。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pow(<span class="string">&quot;这里输入被平方的数，一般是变量名&quot;</span>，<span class="string">&quot;这里输入次方数&quot;</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法适用于高阶次方运算。</p><h3 id="2、使用连乘的方式"><a href="#2、使用连乘的方式" class="headerlink" title="2、使用连乘的方式"></a>2、使用连乘的方式</h3><p>&emsp;&emsp;这个方法相对而言就简单很多，同样的以上面的代码为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">scanf(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">b=a*a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种算法就是明显的数学问题了，这里就不在多说。不过值得一提的是，当计算简单的加减乘除的时候，程序不需要加上<code>&lt;math.h&gt;</code>这个头文件。当然，如果需要计算复杂一点的式子，比如用上面的pow函数计算次方，那你就需要用上<code>&lt;math.h&gt;</code>这个头文件了。</p><h2 id="三、用define定义一个常数"><a href="#三、用define定义一个常数" class="headerlink" title="三、用define定义一个常数"></a>三、用define定义一个常数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define a 1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的define就是用来定义一个常量，在定义之后，下面的程序中a就会等于1，不需要再另外作出定义。</p><p>&emsp;&emsp;以上就是我的一些心得，注意，由于博主是一名刚刚初学C语言的学生，可能会在理解上或者概念上出现一些问题，所以以上内容仅供参考。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello world</title>
      <link href="/2020/12/09/Hello%20world/"/>
      <url>/2020/12/09/Hello%20world/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="/img/Old-blog.png"><br>&emsp;&emsp;上面那张图是我在高三的时候建立的博客，当时用的还是<a href="https://gridea.dev/">Gridea</a>推送+<a href="https://coding.net/">Coding page</a>代码托管，进行静态博客搭建。这是也我目前所能够了解到的最为简单快速的搭建方式。前阵子想尝试用Hexo重新建立一个静态博客，也算是给我的博客翻新了。结果一不小心将Coding上存放我博客文件的仓库删掉了。最后不得不将建立静态博客这一议程提前进行。</p><p>&emsp;&emsp;其实一开始是打算用<a href="https://hexo.io/zh-cn/">Hexo</a>+coding部署的，直到昨天我还在坚持这一想法。但由于部署过程频频报错，有时候甚至连错误信息都没有，查了很多资料都无解。最后实在是受不了了，才用Hexo+<a href="https://github.com/">Github</a>部署我的博客。这里对后面想要建立静态博客的朋友们提个建议——在短时间内，最好用Hexo+Github的方式来搭建自己的静态博客。</p><p>&emsp;&emsp;还在念初中的时候突发奇想，寻思着要建立一个网站，搭建一个论坛式的网络平台。苦于当时的我还没有本事从头开始码代码，但凭借着这一时的冲动，直接买了一本搭建网站的教程，打算从头开始学。当时我把我的想法告诉了几个好哥们。几个人都对我摇了摇头，一致认为我的想法难以实现。现在想来确实如此，毕竟仅凭一时的热情，很难实现这一目标。</p><p>&emsp;&emsp;再后来到了高中那会儿，偶然的在酷安上看到一篇依托Coding page加上Hexo静态博客框架建立静态博客的教程。那时也是抱着尝试的心理，看着教程的步骤，从安装环境开始，一步一步执行教程中的命令。但是无论如何尝试，总是会有报错信息，到最后连查资料也没用了。放弃了之后又找到了Gridea,这里不得不说Gridea的可视化界面对小白真的是极其友好，然后就有了博文开头的那张图。但是鉴于Gridea的适配主题少的可怜，于是前几天我又不得不用Coding+Github来搭建我的博客。虽然界面简单，但这对于极少实现目标的我而言，已经是莫大的成功了。</p><p>&emsp;&emsp;一直以来，只要是我认定想要做的事情，似乎总是以失败而告终。每当我和别人谈起我的想法时，要么觉得太过于困难，难以实现。要么就觉得没有必要。以至于在很长的一段时间里，我在不停的反思自己，自己对待事物时是不是太过于理想化，以至于在现实世界中无法实现。</p><p>&emsp;&emsp;一路走来，我遇到过别人不带掩饰的嘲讽和质疑。这里要对一直以来相信并支持我的老师同学、家人朋友说一句谢谢！当然了，对于曾经那些质疑与嘲讽过我的人，我想说，我现在过的很好，曾经你们说的那些我做不到的或者不应该做到的事情我都在一个一个努力的实现。</p><p>&emsp;&emsp;最让我沮丧的莫过于在兴高采烈地将想法告诉别人时，别人冷不丁地给你来一句“不可能”。虽然在心里也直到自己就这副德行，有着大半辈子摆脱不了的惰性，智商也是低的让人心疼。但与之相配的，我有着天生的固执性格，这也是我在沮丧之余为数不多的能够感到安慰的方面。我不愿意放弃事物的每一个可能性，每当别人劝我“你做不到的，放弃吧！”的时候，我反而会坚定自己的想法。这里要承认我的固执有时候也会伤害到身边的人，这里要向曾被我伤害过的人说一句抱歉！</p><p>&emsp;&emsp;对于我而言，机会很快就稍纵即逝，可能对于你们而言，这些事情都是微不足道的，不值一提。但是我害怕失去，失去那些我本可以触碰到的东西。有时你们可以轻而易举的获得你们想要的东西，但是我不能，或者很难做到，所以迫不得已需要付出更多的精力去获得那些我想要的东西。</p><p>&emsp;&emsp;值得一提的是，在大学同学的支持下，初中那时的想法正在逐渐实现。未来充满了各种的未知，我不知道下一次的失败是在什么时候。但有一点是显而易见的，那就是我已经从零开始向前迈出了第一步。这一点是着实让我感到惊喜的，我更喜欢这种从无到有不停创造的过程。曾经我对我的高中的同学们说过，不管我以后到了哪所大学，读的怎么样，关键是要实现自己的价值（似乎还听到后面有人笑了一声）╮(╯-╰)╭但是我确信我在实践着我说的话，至于实现与否当然就不是我能左右了嘛……</p><p>&emsp;&emsp;不管怎么说，还是要脚踏实地地走好人生的每一步。随着我渐渐地成长，曾经的那些不成熟的想法已经成为了我尘封的回忆，等待着我哪天终于停下了急促的脚步，坐下来仔细回味着那些过去的稚嫩。未来的我要变得更成熟些，免得又提出一些幼稚的想法被人笑话(￣、￣)</p><p>&emsp;&emsp;借着我新博客的发布，就把这作为一个契机，或者说是一个起点吧！</p><p>#include&lt;stdio.h&gt;<br>int main()<br>{<br>printf(“Hello world.I’m comming!”);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 我的日记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
